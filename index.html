<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星尘交互 - 最终修复版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; display: flex; align-items: center; justify-content: center; height: 100vh; color: white; font-family: sans-serif;}
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        /* 隐藏视频，通过脚本处理 */
        #input-video { display: none; }
        
        /* 加载与UI */
        #ui { position: absolute; z-index: 10; text-align: center; pointer-events: none; }
        #status { font-size: 16px; color: #00ffaa; margin-bottom: 10px; text-shadow: 0 0 5px #00ffaa; }
        #loading-bar { width: 200px; height: 4px; background: #333; margin: 0 auto; border-radius: 2px; overflow: hidden; display: none; }
        #loading-progress { width: 0%; height: 100%; background: #00aaff; transition: width 0.3s; }
        
        /* 启动按钮 */
        #start-btn { 
            pointer-events: auto; display: none; padding: 12px 30px; 
            background: rgba(0, 170, 255, 0.2); border: 1px solid #00aaff; 
            color: #00aaff; font-size: 16px; cursor: pointer; letter-spacing: 2px; 
            transition: all 0.3s; text-transform: uppercase;
        }
        #start-btn:hover { background: #00aaff; color: #000; box-shadow: 0 0 15px #00aaff; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="ui">
        <div id="status">正在建立连接...</div>
        <div id="loading-bar"><div id="loading-progress"></div></div>
        <button id="start-btn">开启星尘</button>
    </div>

    <video id="input-video" playsinline webkit-playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>

    <script>
        const statusEl = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');
        const loadBar = document.getElementById('loading-bar');
        const loadProgress = document.getElementById('loading-progress');
        const videoElement = document.getElementById('input-video');

        // --- 第一部分：Three.js 视觉效果 (粒子星球) ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02); // 增加雾气
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 创建粒子
        const particleCount = 8000;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const basePositions = [];
        const colors = [];
        const colorBase = new THREE.Color(0x0088ff);
        const colorActive = new THREE.Color(0xff0055);

        for(let i=0; i<particleCount; i++) {
            // 球体分布
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;
            const r = 15;
            
            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(phi);
            
            positions.push(x, y, z);
            basePositions.push(x, y, z); // 记住原始位置
            colors.push(colorBase.r, colorBase.g, colorBase.b);
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({ 
            size: 0.3, 
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8
        });
        
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // 动画变量
        let isExploded = false;
        let progress = 0; // 0 = 聚拢, 1 = 扩散

        function animate() {
            requestAnimationFrame(animate);
            
            // 状态平滑过渡
            const target = isExploded ? 1 : 0;
            progress += (target - progress) * 0.1;
            
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;
            const t = Date.now() * 0.001;

            for(let i=0; i<particleCount; i++) {
                const ix = i*3;
                const bx = basePositions[ix], by = basePositions[ix+1], bz = basePositions[ix+2];
                
                // 基础自转
                const cosT = Math.cos(t * 0.1);
                const sinT = Math.sin(t * 0.1);
                
                // 扩散计算：向外推 + 噪点
                const noise = Math.sin(bx * 0.1 + t) * Math.cos(by * 0.1 + t);
                const explodeScale = 1 + (progress * 3.0) + (progress * noise * 0.5);
                
                posAttr.array[ix] = bx * explodeScale;
                posAttr.array[ix+1] = by * explodeScale;
                posAttr.array[ix+2] = bz * explodeScale;
                
                // 颜色变化
                const r = colorBase.r + (colorActive.r - colorBase.r) * progress;
                const g = colorBase.g + (colorActive.g - colorBase.g) * progress;
                const b = colorBase.b + (colorActive.b - colorBase.b) * progress;
                
                colAttr.array[ix] = r;
                colAttr.array[ix+1] = g;
                colAttr.array[ix+2] = b;
            }
            
            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
            particles.rotation.y = t * 0.1 * (1 - progress * 0.8); // 扩散时减慢旋转
            
            renderer.render(scene, camera);
        }
        animate();

        // --- 第二部分：MediaPipe 核心逻辑 (修复版) ---
        
        statusEl.innerText = "正在下载 AI 模型...";
        loadBar.style.display = 'block';
        loadProgress.style.width = '30%';

        // 关键修复：强制版本一致性，避免 CDN 混用导致的静默失败
        const mpVersion = '0.4.1646424915';
        const hands = new Hands({
            locateFile: (file) => {
                // 强制所有依赖文件 (wasm, tflite) 都使用完全相同的版本 URL
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@${mpVersion}/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        // 关键逻辑：一旦 Results 回调函数被触发，哪怕是空的，也说明模型加载成功了
        let isModelLoaded = false;
        
        hands.onResults((results) => {
            if(!isModelLoaded) {
                isModelLoaded = true;
                statusEl.innerText = "系统就绪";
                loadBar.style.display = 'none';
                // 这里我们不需要手动显示按钮，视频流接通后自然开始交互
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // 识别到手
                statusEl.innerText = "检测到信号";
                const landmarks = results.multiHandLandmarks[0];
                
                // 计算张开程度：指尖到手腕的距离
                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const distance = Math.sqrt(
                    Math.pow(middleTip.x - wrist.x, 2) + 
                    Math.pow(middleTip.y - wrist.y, 2)
                );
                
                // 阈值判断
                if (distance > 0.25) {
                    isExploded = true; // 张开
                } else {
                    isExploded = false; // 握拳
                }
            } else {
                statusEl.innerText = "未检测到手部";
                isExploded = false;
            }
        });

        // 启动逻辑
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // 等待用户点击，解决浏览器自动播放策略
        statusEl.innerText = "点击按钮启动";
        loadProgress.style.width = '100%';
        startBtn.style.display = 'inline-block';

        startBtn.addEventListener('click', () => {
            startBtn.style.display = 'none';
            loadBar.style.display = 'block';
            statusEl.innerText = "正在初始化摄像头...";
            
            cameraUtils.start()
                .then(() => {
                    statusEl.innerText = "正在分析...";
                })
                .catch(err => {
                    console.error(err);
                    statusEl.innerText = "摄像头启动失败 (请允许权限)";
                    alert("请允许摄像头权限！");
                });
        });

        // 窗口自适应
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
    </script>
</body>
</html>