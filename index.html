<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ˜Ÿå°˜äº¤äº’ - æœ€ç»ˆç‰ˆæœ¬</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; display: flex; align-items: center; justify-content: center; height: 100vh; color: white; font-family: sans-serif;}
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #input-video { display: none; }
        
        /* åŠ è½½ä¸UI */
        #ui { position: absolute; z-index: 10; text-align: center; pointer-events: none; }
        #status { font-size: 16px; color: #00ffaa; margin-bottom: 10px; text-shadow: 0 0 5px #00ffaa; }
        #info-box { 
            position: absolute; bottom: 20px; right: 20px; 
            padding: 10px; background: rgba(0,0,0,0.5); 
            border: 1px solid rgba(0, 170, 255, 0.5); font-size: 12px; 
            color: #00aaff; text-align: left; pointer-events: none; 
            line-height: 1.6;
        }
        
        /* å¯åŠ¨æŒ‰é’® */
        #start-btn { 
            pointer-events: auto; display: none; padding: 12px 30px; 
            background: rgba(0, 170, 255, 0.2); border: 1px solid #00aaff; 
            color: #00aaff; font-size: 16px; cursor: pointer; letter-spacing: 2px; 
            transition: all 0.3s; text-transform: uppercase;
        }
        #start-btn:hover { background: #00aaff; color: #000; box-shadow: 0 0 15px #00aaff; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="ui">
        <div id="status">æ­£åœ¨å»ºç«‹è¿æ¥...</div>
        <button id="start-btn">å¼€å¯æ˜Ÿå°˜</button>
    </div>

    <div id="info-box">
        <div>çŠ¶æ€: <span id="current-state">èšæ‹¢</span></div>
        <div>å½¢æ€: <span id="current-shape">çƒä½“</span></div>
        <div>äº¤äº’: âœ‹æ‰©æ•£ / âœŠèšæ‹¢ / ğŸ‘‹å·¦å³æŒ¥æ‰‹åˆ‡æ¢å½¢æ€</div>
    </div>


    <video id="input-video" playsinline webkit-playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>

    <script>
        const statusEl = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');
        const videoElement = document.getElementById('input-video');
        const stateEl = document.getElementById('current-state');
        const shapeEl = document.getElementById('current-shape');

        // --- å…¨å±€é…ç½®ä¸çŠ¶æ€ ---
        const mpVersion = '0.4.1646424915';
        const particleCount = 10000;
        let isExploded = false; // æ˜¯å¦æ‰©æ•£
        let progress = 0; // 0-1 æ‰©æ•£è¿›åº¦
        let shapeProgress = 0; // 0-1 å½¢æ€åˆ‡æ¢è¿›åº¦
        let currentShape = 'sphere'; // å½“å‰å½¢æ€
        let lastHandX = 0; // ç”¨äºæ»‘åŠ¨æ£€æµ‹
        let lastGestureTime = 0; // ç”¨äºæ»‘åŠ¨å†·å´

        // --- 1. Three.js è§†è§‰ç³»ç»Ÿ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // ç²’å­æ•°æ®
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const basePositions = []; // ç›®æ ‡å½¢æ€ A: çƒä½“
        const cubePositions = []; // ç›®æ ‡å½¢æ€ B: ç«‹æ–¹ä½“
        const colors = [];
        const colorBase = new THREE.Color(0x0088ff);
        const colorActive = new THREE.Color(0xff0055);
        const sizes = []; // ç”¨äºç€è‰²å™¨çš„æ¢é’ˆå¤§å°
        
        const rSphere = 15;
        const rCube = 25;

        for(let i=0; i<particleCount; i++) {
            // çƒä½“æ•°æ® (Base)
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;
            basePositions.push(
                rSphere * Math.cos(theta) * Math.sin(phi),
                rSphere * Math.sin(theta) * Math.sin(phi),
                rSphere * Math.cos(phi)
            );
            
            // ç«‹æ–¹ä½“æ•°æ® (Target)
            cubePositions.push(
                (Math.random() - 0.5) * rCube,
                (Math.random() - 0.5) * rCube,
                (Math.random() - 0.5) * rCube
            );

            // åˆå§‹åŒ–ä½ç½®
            positions[i*3] = basePositions[i*3];
            positions[i*3+1] = basePositions[i*3+1];
            positions[i*3+2] = basePositions[i*3+2];
            
            colors.push(colorBase.r, colorBase.g, colorBase.b);
            sizes.push(Math.random() * 1.5 + 0.5);
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1)); // ä¼ é€’ç»™ç€è‰²å™¨

        // è‡ªå®šä¹‰ç€è‰²å™¨æè´¨ (å®ç°æ¢é’ˆæ•ˆæœ)
        const particleUniforms = {
            uTime: { value: 0 },
            uBaseColor: { value: colorBase },
            uActiveColor: { value: colorActive },
            uProgress: { value: 0.0 } // æ‰©æ•£è¿›åº¦
        };

        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: particleUniforms,
            vertexShader: `
                uniform float uTime;
                uniform float uProgress;
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                varying float vOpacity;
                
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    
                    // ç²’å­å¤§å°éšè·ç¦»å˜åŒ–ï¼Œå¹¶æ ¹æ®æ‰‹åŠ¿æ‰©æ•£å¤§å°
                    gl_PointSize = size * (200.0 / -mvPosition.z) * (1.0 + uProgress * 2.0);
                    
                    gl_Position = projectionMatrix * mvPosition;
                    vOpacity = 1.0;
                }
            `,
            fragmentShader: `
                uniform vec3 uActiveColor;
                uniform vec3 uBaseColor;
                uniform float uProgress;
                varying vec3 vColor;
                
                void main() {
                    vec2 xy = gl_PointCoord.xy - vec2(0.5);
                    float r = length(xy);
                    if (r > 0.5) discard;
                    
                    // é¢œè‰²æ’å€¼ï¼šæ ¹æ®æ‰©æ•£è¿›åº¦æ··åˆé¢œè‰²
                    vec3 finalColor = mix(vColor, uActiveColor, uProgress);
                    
                    // è¾¹ç¼˜å‘å…‰å’Œä¸­å¿ƒäº®åº¦
                    float strength = smoothstep(0.5, 0.4, r) * (0.5 + uProgress * 0.5);
                    
                    gl_FragColor = vec4(finalColor * strength, strength);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(geometry, shaderMaterial);
        scene.add(particles);


        // --- 2. Web Audio ç³»ç»Ÿ (éŸ³æ•ˆ) ---
        let audioCtx;
        let oscillator;
        let gainNode;

        function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if(audioCtx.state === 'suspended') audioCtx.resume();
                
                oscillator = audioCtx.createOscillator();
                gainNode = audioCtx.createGain();
                
                oscillator.type = 'sine'; // ç§‘å¹»é£
                gainNode.gain.setValueAtTime(0, audioCtx.currentTime); // åˆå§‹é™éŸ³
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
            } catch (e) {
                console.warn("Audio Context initialization failed:", e);
            }
        }

        function updateAudio(currentProgress) {
            if (!oscillator || !audioCtx) return;
            
            // é¢‘ç‡ (éŸ³é«˜) éšæ‰©æ•£ç¨‹åº¦å˜åŒ–ï¼šèšæ‹¢(200Hz) -> æ‰©æ•£(500Hz)
            const targetFreq = 200 + currentProgress * 300;
            // éŸ³é‡éšæ‰©æ•£ç¨‹åº¦å˜åŒ–
            const targetGain = 0.03 + currentProgress * 0.07; 
            
            oscillator.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.05);
            gainNode.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.05);
        }
        
        function playSwipeSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gn = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(350, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
            gn.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gn.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
            
            osc.connect(gn);
            gn.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }


        // --- 3. åŠ¨ç”»å¾ªç¯ä¸å½¢æ€æ›´æ–° ---
        function animate() {
            requestAnimationFrame(animate);
            
            const targetExplode = isExploded ? 1 : 0;
            progress += (targetExplode - progress) * 0.1; // æ‰©æ•£è¿›åº¦ Lerp
            
            // å½¢æ€åˆ‡æ¢è¿›åº¦ Lerp
            const targetShape = currentShape === 'sphere' ? 0 : 1;
            shapeProgress += (targetShape - shapeProgress) * 0.1;

            const posAttr = geometry.attributes.position;
            const t = Date.now() * 0.001;
            
            // æ›´æ–°ç€è‰²å™¨ Uniforms
            particleUniforms.uTime.value = t;
            particleUniforms.uProgress.value = progress;

            for(let i=0; i<particleCount; i++) {
                const ix = i*3;
                
                // 1. å½¢æ€æ’å€¼ï¼šä»çƒä½“ (basePositions) æ¸å˜åˆ°ç«‹æ–¹ä½“ (cubePositions)
                const sx = basePositions[ix], sy = basePositions[ix+1], sz = basePositions[ix+2];
                const cx = cubePositions[ix], cy = cubePositions[ix+1], cz = cubePositions[ix+2];
                
                // shapeProgress (0 -> 1) æ§åˆ¶æ··åˆ
                const tx = sx + (cx - sx) * shapeProgress;
                const ty = sy + (cy - sy) * shapeProgress;
                const tz = sz + (cz - sz) * shapeProgress;

                // 2. æ‰©æ•£/èšæ‹¢è®¡ç®—ï¼šåœ¨ç›®æ ‡å½¢æ€ä¸Šè¿›è¡Œæ”¾å¤§/ç¼©å°
                const explodeScale = 1 + (progress * 1.5); // æ‰©æ•£æœ€å¤§æ”¾å¤§ 1.5 å€
                
                posAttr.array[ix] = tx * explodeScale;
                posAttr.array[ix+1] = ty * explodeScale;
                posAttr.array[ix+2] = tz * explodeScale;
            }
            
            posAttr.needsUpdate = true;
            
            // è‡ªåŠ¨æ—‹è½¬ï¼šèšæ‹¢æ—¶è½¬å¾—å¿«ï¼Œæ‰©æ•£æ—¶æ…¢
            particles.rotation.y = t * 0.1 * (1 - progress * 0.8);
            
            // æ›´æ–°éŸ³æ•ˆ
            updateAudio(progress);
            
            // æ›´æ–° UI
            stateEl.innerText = progress > 0.8 ? 'æ‰©æ•£' : (progress < 0.2 ? 'èšæ‹¢' : 'è¿‡æ¸¡ä¸­');
            shapeEl.innerText = shapeProgress > 0.5 ? 'ç«‹æ–¹ä½“' : 'çƒä½“';

            renderer.render(scene, camera);
        }
        animate();


        // --- 4. MediaPipe æ‰‹åŠ¿ä¸äº¤äº’é€»è¾‘ ---

        const hands = new Hands({
            locateFile: (file) => {
                // å…³é”®ï¼šç¡®ä¿æ¨¡å‹è·¯å¾„æ­£ç¡®ï¼Œä½¿ç”¨é”å®šç‰ˆæœ¬
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@${mpVersion}/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        // æ‰‹åŠ¿ç»“æœå¤„ç†
        hands.onResults((results) => {
            if(!videoElement.style.display) {
                // æ¨¡å‹åŠ è½½æˆåŠŸï¼Œä½†åªåœ¨å¯åŠ¨åæ‰æ‰§è¡Œ
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const indexRoot = landmarks[5]; // é£ŸæŒ‡æ ¹éƒ¨ï¼Œç”¨äºæ»‘åŠ¨è¿½è¸ª

                // 1. æ‰©æ•£/èšæ‹¢è¯†åˆ« (å¼ å¼€/æ¡æ‹³)
                const distance = Math.sqrt(
                    Math.pow(middleTip.x - wrist.x, 2) + 
                    Math.pow(middleTip.y - wrist.y, 2)
                );
                
                if (distance > 0.25) { // é˜ˆå€¼
                    isExploded = true;
                } else {
                    isExploded = false;
                }

                // 2. å½¢æ€åˆ‡æ¢è¯†åˆ« (æ»‘åŠ¨)
                const currX = indexRoot.x;
                const now = Date.now();
                const swipeThreshold = 0.15; // æ»‘åŠ¨è·ç¦»é˜ˆå€¼ (æ ‡å‡†åŒ–åæ ‡ 0-1)
                const swipeCooldown = 1500; // å†·å´æ—¶é—´ 1.5 ç§’

                if (lastHandX !== 0 && (now - lastGestureTime > swipeCooldown)) {
                    const deltaX = currX - lastHandX;
                    
                    if (Math.abs(deltaX) > swipeThreshold) {
                        // è¯†åˆ«åˆ°æœ‰æ•ˆæ»‘åŠ¨
                        currentShape = currentShape === 'sphere' ? 'cube' : 'sphere';
                        playSwipeSound();
                        lastGestureTime = now;
                    }
                }
                lastHandX = currX; // æ›´æ–°ä¸Šä¸€å¸§ä½ç½®
                statusEl.innerText = "æ­£åœ¨åˆ†æ..."; // ç¡®ä¿çŠ¶æ€æ›´æ–°
                
            } else {
                // æœªæ£€æµ‹åˆ°æ‰‹éƒ¨ï¼Œæ¢å¤èšæ‹¢
                isExploded = false;
                lastHandX = 0;
                statusEl.innerText = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
            }
        });


        // --- 5. å¯åŠ¨æµç¨‹ ---

        statusEl.innerText = "AI æ¨¡å‹åŠ è½½ä¸­...";
        hands.onLoaded = () => {
            statusEl.innerText = "æ¨¡å‹åŠ è½½å®Œæ¯•ï¼Œè¯·ç‚¹å‡»å¯åŠ¨";
            startBtn.style.display = 'inline-block';
        };

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        startBtn.addEventListener('click', () => {
            startBtn.style.display = 'none';
            statusEl.innerText = "æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´...";
            
            // å¯åŠ¨éŸ³é¢‘å’Œæ‘„åƒå¤´
            initAudio(); 
            cameraUtils.start()
                .then(() => {
                    statusEl.innerText = "AI è¯†åˆ«ä¸­...";
                })
                .catch(err => {
                    statusEl.innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ (è¯·å…è®¸æƒé™)";
                    alert("è¯·å…è®¸æ‘„åƒå¤´æƒé™ï¼");
                });
        });

        // çª—å£è‡ªé€‚åº”
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
    </script>
</body>
</html>